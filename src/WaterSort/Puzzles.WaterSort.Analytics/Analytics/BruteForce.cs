#define CHECK_DETOUR_STEP

namespace Puzzles.WaterSort.Analytics;

/// <summary>
/// Provides a way to make an exhaustive search to find for all possible valid steps in the whole solving environment.
/// </summary>
public sealed class BruteForce
{
	/// <summary>
	/// Indicates the collector.
	/// </summary>
	private readonly Collector _collector = new();


	/// <inheritdoc cref="CreateTree(Puzzle, out LinkedList{InvertedBruteForceNode})"/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public BruteForceTree CreateTree(Puzzle puzzle) => CreateTree(puzzle, out _);

	/// <summary>
	/// Create a <see cref="BruteForceTree"/> to describe each steps and its related steps.
	/// </summary>
	/// <param name="puzzle">The puzzle.</param>
	/// <param name="invertedNodes">The inverted nodes.</param>
	/// <returns>A <see cref="BruteForceTree"/> instance.</returns>
	public BruteForceTree CreateTree(Puzzle puzzle, out LinkedList<InvertedBruteForceNode> invertedNodes)
	{
		var startEqualityComparer = EqualityComparer<Step>.Create(
			static (left, right) => left.StartTubeIndex == right.StartTubeIndex,
			static tube => tube.StartTubeIndex
		);

		// This is a n-ary tree, we should firstly add all possible steps found into one root node.
		invertedNodes = new LinkedList<InvertedBruteForceNode>();
		var rootNode = new InvertedBruteForceNode(puzzle.Clone());
		invertedNodes.AddLast(rootNode);

		var queue = new LinkedList<InvertedBruteForceNode>();
		foreach (var step in new HashSet<Step>([.. _collector.Collect(puzzle)], startEqualityComparer))
		{
			var puzzleApplied = puzzle.Clone();
			puzzleApplied.Apply(step);

			var node = new InvertedBruteForceNode(step, puzzleApplied, rootNode);
			queue.AddLast(node);
			invertedNodes.AddLast(node);
		}

		// Use BFS algorithm to make such exhaustive searching.
		while (queue.Count != 0)
		{
			var currentNode = queue.RemoveFirstNode();
			var (_, p, _) = currentNode;
			if (p.IsSolved)
			{
				continue;
			}

			var foundSteps = _collector.Collect(p);
			foreach (var step in foundSteps)
			{
#if CHECK_DETOUR_STEP
				// Check whether here exists a step that is unnecessary:
				// If color (a) in tube (A) wants to be filled into another tube (B) and (C),
				// but (C) is an empty tube, while (B) is not.
				// We will conclude that (a) from (A) to (B) is valid, and (A) to (C) is not because it produces a "detour" step,
				// because the path will be (A) to (C) and then (C) to (B), where is equal to (A) to (B) directly.
				if (isDetourStep(p, step, foundSteps))
				{
					continue;
				}
#endif

				var puzzleApplied = p.Clone();
				puzzleApplied.Apply(step);

				var node = new InvertedBruteForceNode(step, puzzleApplied, currentNode);
				queue.AddLast(node);
				invertedNodes.AddLast(node);
			}
		}

		// Return the root node.
		return new(getRootNode(invertedNodes));


#if CHECK_DETOUR_STEP
		static bool isDetourStep(Puzzle currentState, Step currentStep, ReadOnlySpan<Step> steps)
		{
			var startTube = currentState[currentStep.StartTubeIndex];
			var endTube = currentState[currentStep.EndTubeIndex];
			var topColor = startTube.TopColor;
			if (topColor == Color.MaxValue)
			{
				return true;
			}

			// Check whether the target tube (end tube) can receive this color, and it's empty.
			// We may not check for the case whether the end tube can receive such color, because it is generated by collector,
			// which is a valid moving step - it must be correct.
			if (!endTube.IsEmpty)
			{
				return false;
			}

			foreach (var step in steps)
			{
				if (step == currentStep || step.StartTubeIndex != currentStep.StartTubeIndex)
				{
					continue;
				}

				var currentStepEndTube = currentState[step.EndTubeIndex];
				if (currentStepEndTube.IsEmpty)
				{
					continue;
				}

				// The current target tube is not empty, but the step 'currentStep' mentioned above is a valid move
				// that will move the color into an empty tube.
				// However, here the step will make the color move into a non-empty tube, which is also a valid step,
				// causing a "detour" step described above.
				return true;
			}
			return false;
		}
#endif

		static BruteForceNode getRootNode(LinkedList<InvertedBruteForceNode> nodes)
		{
			// Create a dictionary to map original nodes to new tree nodes.
			var map = new Dictionary<InvertedBruteForceNode, BruteForceNode>();

			// Populate the dictionary with new TreeNode instances.
			foreach (var node in nodes)
			{
				map[node] = new BruteForceNode(node.Step, node.CurrentPuzzle);
			}

			// Set children for each TreeNode based on the parent property.
			var root = default(BruteForceNode);
			foreach (var node in nodes)
			{
				if (node.Parent is null)
				{
					// Identify the root node.
					root = map[node];
					continue;
				}

				if (map.TryGetValue(node.Parent, out var n))
				{
					n.Children.Add(map[node]);
				}
			}

			return root!;
		}
	}
}
