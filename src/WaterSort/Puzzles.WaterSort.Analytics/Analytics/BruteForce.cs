#define CHECK_DETOUR_STEP

namespace Puzzles.WaterSort.Analytics;

/// <summary>
/// Provides a way to make an exhaustive search to find for all possible valid steps in the whole solving environment.
/// </summary>
public sealed class BruteForce
{
	/// <summary>
	/// Indicates the collector.
	/// </summary>
	private readonly Collector _collector = new();


	/// <summary>
	/// Create a <see cref="BruteForceNode"/> to describe each steps and its related steps.
	/// </summary>
	/// <param name="puzzle">The puzzle.</param>
	/// <returns>A <see cref="BruteForceNode"/> instance.</returns>
	public BruteForceNode CreateTree(Puzzle puzzle)
	{
		var startEqualityComparer = EqualityComparer<Step>.Create(
			static (left, right) => left.StartTubeIndex == right.StartTubeIndex,
			static tube => tube.StartTubeIndex
		);

		// This is a n-ary tree, we should firstly add all possible steps found into one root node.
		var validNodes = new LinkedList<ParentLinkedNode>();
		var rootNode = new ParentLinkedNode(puzzle.Clone());
		validNodes.AddLast(rootNode);

		var queue = new LinkedList<ParentLinkedNode>();
		foreach (var step in new HashSet<Step>([.. _collector.Collect(puzzle)], startEqualityComparer))
		{
			var puzzleApplied = puzzle.Clone();
			puzzleApplied.Apply(step);

			var node = new ParentLinkedNode(step, puzzleApplied, rootNode);
			queue.AddLast(node);
			validNodes.AddLast(node);
		}

		// Use BFS algorithm to make such exhaustive searching.
		while (queue.Count != 0)
		{
			var currentNode = queue.RemoveFirstNode();
			var (_, p, _) = currentNode;
			if (p.IsSolved)
			{
				continue;
			}

			var foundSteps = _collector.Collect(p);
			foreach (var step in foundSteps)
			{
#if CHECK_DETOUR_STEP
				// Check whether here exists a step that is unnecessary:
				// If color (a) in tube (A) wants to be filled into another tube (B) and (C),
				// but (C) is an empty tube, while (B) is not.
				// We will conclude that (a) from (A) to (B) is valid, and (A) to (C) is not because it produces a "detour" step,
				// because the path will be (A) to (C) and then (C) to (B), where is equal to (A) to (B) directly.
				if (isDetourStep(p, step, foundSteps))
				{
					continue;
				}
#endif

				var puzzleApplied = p.Clone();
				puzzleApplied.Apply(step);

				var node = new ParentLinkedNode(step, puzzleApplied, currentNode);
				queue.AddLast(node);
				validNodes.AddLast(node);
			}
		}

		// Return the root node.
		return getRootNode(validNodes);


#if CHECK_DETOUR_STEP
		static bool isDetourStep(Puzzle currentState, Step currentStep, ReadOnlySpan<Step> steps)
		{
			var startTube = currentState[currentStep.StartTubeIndex];
			var endTube = currentState[currentStep.EndTubeIndex];
			var topColor = startTube.TopColor;
			if (topColor == Color.MaxValue)
			{
				return true;
			}

			// Check whether the target tube (end tube) can receive this color, and it's empty.
			// We may not check for the case whether the end tube can receive such color, because it is generated by collector,
			// which is a valid moving step - it must be correct.
			if (!endTube.IsEmpty)
			{
				return false;
			}

			foreach (var step in steps)
			{
				if (step == currentStep || step.StartTubeIndex != currentStep.StartTubeIndex)
				{
					continue;
				}

				var currentStepEndTube = currentState[step.EndTubeIndex];
				if (currentStepEndTube.IsEmpty)
				{
					continue;
				}

				// The current target tube is not empty, but the step 'currentStep' mentioned above is a valid move
				// that will move the color into an empty tube.
				// However, here the step will make the color move into a non-empty tube, which is also a valid step,
				// causing a "detour" step described above.
				return true;
			}
			return false;
		}
#endif

		static BruteForceNode getRootNode(LinkedList<ParentLinkedNode> nodes)
		{
			// Create a dictionary to map original nodes to new tree nodes.
			var map = new Dictionary<ParentLinkedNode, BruteForceNode>();

			// Populate the dictionary with new TreeNode instances.
			foreach (var node in nodes)
			{
				map[node] = new BruteForceNode(node.Step, node.CurrentPuzzle);
			}

			// Set children for each TreeNode based on the parent property.
			var root = default(BruteForceNode);
			foreach (var node in nodes)
			{
				if (node.Parent is null)
				{
					// Identify the root node.
					root = map[node];
					continue;
				}

				if (map.TryGetValue(node.Parent, out var n))
				{
					n.Children.Add(map[node]);
				}
			}

			return root!;
		}
	}
}

/// <summary>
/// Provides a linked list node that describes the parent usages for a step.
/// </summary>
/// <param name="Step">Indicates the step.</param>
/// <param name="CurrentPuzzle">Indicates the current puzzle state.</param>
/// <param name="Parent">Indicates the parent node.</param>
file sealed record ParentLinkedNode(Step Step, Puzzle CurrentPuzzle, ParentLinkedNode? Parent) :
	IEqualityOperators<ParentLinkedNode, ParentLinkedNode, bool>
{
	/// <summary>
	/// Initializes a <see cref="ParentLinkedNode"/> instance.
	/// </summary>
	/// <param name="currentPuzzle">Indicates the current puzzle.</param>
	public ParentLinkedNode(Puzzle currentPuzzle) : this(default, currentPuzzle, null)
	{
	}


	/// <summary>
	/// Indicates the number of ancestors in the whole chain.
	/// </summary>
	public int AncestorsCount
	{
		get
		{
			var result = 0;
			for (var tempNode = this; tempNode is not null && tempNode.Step != default; tempNode = tempNode.Parent)
			{
				result++;
			}
			return result;
		}
	}


	/// <include
	///     file="../../../global-doc-comments.xml"
	///     path="/g/csharp9/feature[@name='records']/target[@name='method' and @cref='PrintMembers']"/>
	private bool PrintMembers(StringBuilder builder)
	{
		// Due to design of the game, two indices cannot be same in a step (start index and end index).
		// Therefore, we can append a condition (== default) to determine whether the value is uninitialized.
		builder.Append($"{nameof(Step)} = ");
		builder.Append(Step == default ? "<default>" : Step.ToString());
		builder.Append($", {nameof(Parent)} = ");
		builder.Append(
			Parent switch
			{
				{ Step: var step } => step == default ? "<default>" : step.ToString(),
				_ => "<null>"
			}
		);
		builder.Append($", {nameof(AncestorsCount)} = ");
		builder.Append(AncestorsCount);
		return true;
	}
}
